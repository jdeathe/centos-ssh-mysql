#!/usr/bin/env bash

source /etc/mysqld-bootstrap.conf

# Set MySQL client root user password
# - Prefer to store encrypted via mysql_config_editor.
# - Fallback to store as plaintext in secured file.
function __configure_mysql_client_root_password ()
{
	local -r password="${1:-}"

	local config
	local -a pids

	if [[ -z ${password} ]]
	then
		return 1
	fi

	if command -v mysql_config_editor &> /dev/null \
		&& command -v sshpass &> /dev/null
	then
		fifo_path="$(
			mktemp -d
		)"

		if [[ ${?} -ne 0 ]]
		then
			>&2 printf -- \
				'%s %s %s\n' \
				"ERROR: Failed to create directory" \
				"${fifo_path}" \
				"- aborting."
			exit 1
		fi

		trap \
			"rm -rf \"${fifo_path}\";" \
			INT TERM EXIT

		mkfifo \
			-m 0600 \
			"${fifo_path}/mypasswd"

		exec \
			{mypasswd_fd}<>"${fifo_path}/mypasswd"

		trap \
			"exec {mypasswd_fd}>&- ;" \
			INT TERM EXIT

		rm -rf \
			"${fifo_path}"

		# Send into background waiting to read the password
		sshpass \
			-d ${mypasswd_fd} \
			mysql_config_editor \
				set \
				--skip-warn \
				--password \
				&
		pids[1]="${!}"

		trap \
			"exec {mypasswd_fd}>&- ; \
				[[ ${pids[1]} -gt 0 ]] && kill -9 ${pids[1]};" \
			INT TERM EXIT

		printf -- \
			'%s\n' \
			"${password}" \
			>&${mypasswd_fd} \
			&
		pids[2]="${!}"

		trap \
			"exec {mypasswd_fd}>&- ; \
				[[ ${pids[1]} -gt 0 ]] && kill -9 ${pids[1]}; \
				[[ ${pids[2]} -gt 0 ]] && kill -9 ${pids[2]};" \
			INT TERM EXIT

		if [[ ${pids[1]} -gt 0 ]]
		then
			wait ${pids[1]}
		fi

		if [[ ${?} -ne 0 ]]
		then
			>&2 printf -- \
				"ERROR: Unable to set MySQL root password - aborting.\n"
			exit 1
		fi

		exec \
			{mypasswd_fd}>&-
	else
		tee /root/.my.cnf &> /dev/null \
			<<-EOT
			[client]
			password={{MYSQL_ROOT_PASSWORD}}
		EOT

		chown root:root \
			/root/.my.cnf
		chmod 0600 \
			/root/.my.cnf

		config="$(< /root/.my.cnf)"

		printf -- \
			'%s\n' \
			"${config//'{{MYSQL_ROOT_PASSWORD}}'/${password}}" \
			> /root/.my.cnf
	fi

	trap - \
		INT TERM EXIT
}

function __get_mysql_init_limit ()
{
	local -r default_value="${1:-60}"

	local value="${MYSQL_INIT_LIMIT}"

	if ! __is_valid_mysql_init_limit "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __get_mysql_init_sql ()
{
	local -r default_value="${1:-"-- Custom Initialisation SQL"}"

	local value="${MYSQL_INIT_SQL}"

	if ! __is_valid_mysql_init_sql "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __get_mysql_init_template ()
{
	local compact="false"
	local database
	local host
	local init_sql="-- Custom Initialisation SQL"
	local password_hashed="false"
	local -a pids
	local template_database="-- Create database"
	local template_identified_by="IDENTIFIED BY"
	local template_privileges="-- Grant privileges"
	local template_user="-- Create user"
	local user

	# Parse options
	while [[ "${#}" -gt 0 ]]
	do
		case "${1}" in
			--compact|--compact=true)
				compact="true"
				shift 1
				;;
			--compact=*)
				compact="false"
				shift 1
				;;
			--database=*)
				database="${1#*=}"
				shift 1
				;;
			--host=*)
				host="${1#*=}"
				shift 1
				;;
			--init-sql=*)
				init_sql="${1#*=}"
				shift 1
				;;
			--password-hashed|--password-hashed=true)
				password_hashed="true"
				shift 1
				;;
			--password-hashed=*)
				password_hashed="false"
				shift 1
				;;
			--user=*)
				user="${1#*=}"
				shift 1
				;;
			*)
				>&2 printf -- \
					'ERROR: Unknown option %s\n' \
					"${1}"
				return 1
				;;
		esac
	done

	fifo_path="$(
		mktemp -d
	)"

	if [[ ${?} -ne 0 ]]
	then
		>&2 printf -- \
			'%s %s %s\n' \
			"ERROR: Failed to create directory" \
			"${fifo_path}" \
			"- aborting."
		exit 1
	fi

	trap \
		"rm -rf \"${fifo_path}\";" \
		INT TERM EXIT

	mkfifo \
		-m 0600 \
		"${fifo_path}"/mysql-init-template

	if [[ -n ${database} ]]
	then
		printf \
			-v template_database \
			-- "%s\nCREATE DATABASE IF NOT EXISTS \`%s\`;" \
			"${template_database}" \
			"{{MYSQL_USER_DATABASE}}"
	fi

	if [[ -n ${user} ]] \
		&& [[ -n ${host} ]]
	then
		if [[ ${password_hashed} == true ]]
		then
			template_identified_by+=" PASSWORD"
		fi

		printf \
			-v template_user \
			-- "%s\nCREATE USER '%s'@'%s' \n%s '%s';" \
			"${template_user}" \
			"{{MYSQL_USER}}" \
			"{{MYSQL_USER_HOST}}" \
			"${template_identified_by}" \
			"{{MYSQL_USER_PASSWORD}}"
	fi

	if [[ -n ${user} ]] \
		&& [[ -n ${database} ]] \
		&& [[ -n ${host} ]]
	then
		printf \
			-v template_privileges \
			-- "%s\nGRANT %s \nON \`%s\`.* \nTO '%s'@'%s';" \
			"${template_privileges}" \
			"ALL PRIVILEGES" \
			"{{MYSQL_USER_DATABASE}}" \
			"{{MYSQL_USER}}" \
			"{{MYSQL_USER_HOST}}"
	fi

	# Listen for the template and output as required
	if [[ ${compact} == false ]]
	then
		cat <<-EOF &
			$(<"${fifo_path}"/mysql-init-template)

		EOF
	else
		cat -s \
			<<-EOF | \
				sed \
					-e '/^[ \t]*--.*$/d' \
					-e 's/;[ \t]*--.*$/;/g' \
					-e '/^$/d' \
					| \
				awk \
					'{ ORS=( /;$/ ? RS:FS ) } 1' \
				&
			$(<"${fifo_path}"/mysql-init-template)
		EOF
	fi
	pids[1]="${!}"

	# Generate the initialisation SQL template
	cat \
		<<-EOT > "${fifo_path}"/mysql-init-template &

		-- =============================================================================
		-- Initialisation SQL
		-- -----------------------------------------------------------------------------
		-- Secure MySQL
		DROP DATABASE IF EXISTS test;
		DELETE FROM mysql.user WHERE User='' OR User='root' AND Host != 'localhost';
		DELETE FROM mysql.db WHERE Db='test' OR Db='test\\_%';
		${template_database}
		${template_user}
		-- =============================================================================
		-- Custom Initialisation SQL start
		-- 
		${init_sql}
		-- 
		-- Custom Initialisation SQL end
		-- -----------------------------------------------------------------------------
		${template_privileges}
		GRANT ALL PRIVILEGES 
		ON *.* 
		TO 'root'@'localhost' IDENTIFIED BY '{{MYSQL_ROOT_PASSWORD}}' WITH GRANT OPTION;
		FLUSH PRIVILEGES;
		-- -----------------------------------------------------------------------------
	EOT
	pids[2]="${!}"

	trap \
		"rm -rf \"${fifo_path}\"; \
			[[ ${pids[1]} -gt 0 ]] && kill -9 ${pids[1]}; \
			[[ ${pids[2]} -gt 0 ]] && kill -9 ${pids[2]};" \
		INT TERM EXIT

	if [[ ${pids[1]} -gt 0 ]]
	then
		wait ${pids[1]}
	fi

	if [[ ${?} -ne 0 ]]
	then
		>&2 printf -- \
			"ERROR: Unable to gererate MySQL init template - aborting.\n"
		exit 1
	fi

	rm -rf \
		"${fifo_path}"

	trap - \
		INT TERM EXIT
}

function __get_mysql_root_password ()
{
	local -r default_value="${1:-"$(
		__get_password
	)"}"

	local value="${MYSQL_ROOT_PASSWORD}"

	if [[ -f ${value} ]]
	then
		value="$(< "${value}")"
	fi

	if ! __is_valid_mysql_root_password "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __get_mysql_root_password_hashed ()
{
	local -r default_value="${1:-false}"

	local value="${MYSQL_ROOT_PASSWORD_HASHED}"

	if ! __is_valid_mysql_root_password_hashed "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __get_mysql_subnet ()
{
	local -r default_value="${1:-127.0.0.1}"

	local value="${MYSQL_SUBNET}"

	if ! __is_valid_mysql_subnet "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __get_mysql_user ()
{
	local -r default_value="${1}"

	local value="${MYSQL_USER}"

	if ! __is_valid_mysql_user "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __get_mysql_user_database ()
{
	local -r default_value="${1}"

	local value="${MYSQL_USER_DATABASE}"

	if ! __is_valid_mysql_user_database "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __get_mysql_user_host ()
{
	local -r client_subnet="${1:-"$(
		__get_mysql_subnet
	)"}"

	local value

	case "${client_subnet}" in
		0.0.0.0|0.0.0.0/0.0.0.0)
			# Connect from any network
			value="%"
			;;
		127.0.0.1)
			# Internal connection
			value="localhost"
			;;
		*)
			# User defined host / subnet
			value="${client_subnet}"
			;;
	esac

	printf -- '%s' "${value}"
}

function __get_mysql_user_password ()
{
	local -r default_value="${1:-"$(
		__get_password
	)"}"

	local value="${MYSQL_USER_PASSWORD}"

	if [[ -f ${value} ]]
	then
		value="$(< "${value}")"
	fi

	if ! __is_valid_mysql_user_password "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __get_mysql_user_password_hashed ()
{
	local -r default_value="${1:-false}"

	local value="${MYSQL_USER_PASSWORD_HASHED}"

	if ! __is_valid_mysql_user_password_hashed "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __get_option ()
{
	local -r value="$(
		/usr/bin/my_print_defaults "${1}" \
		| sed -n "s/^--${2}=//p" \
		| tail -n 1
	)"

	printf -- '%s' "${value:-"${3}"}"
}

function __get_password ()
{
	local -r length="${1:-16}"
	local -r password="$(
		head -n 4096 /dev/urandom \
		| tr -cd '[:alnum:]' \
		| cut -c1-"${length}"
	)"

	printf -- '%s' "${password}"
}

function __have_mysql_access ()
{
	local -r database="${3:-mysql}"
	local -r password="${2:-}"
	local -r user="${1:-root}"

	if [[ ${user} == root ]]
	then
		if mysql \
			--protocol=socket \
			--user="${user}" \
			-e "use ${database}" \
			2> /dev/null;
		then
			return 0
		fi
	else
		if mysql \
			--protocol=socket \
			--user="${user}" \
			--password="${password}" \
			-e "use ${database}" \
			2> /dev/null;
		then
			return 0
		fi
	fi

	return 1
}

function __is_mysql_datadir_populated ()
{
	local -r directory="${1:-"$(
		__get_option \
			mysqld \
			datadir \
			"/var/lib/mysql"
	)"}"

	# Test for the InnoDB shared tablespace
	if [[ -f ${directory}/ibdata1 ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_mysql_init_limit ()
{
	local -r non_zero_integer='^[1-9][0-9]*$'
	local -r value="${1}"

	if [[ ${value} =~ ${non_zero_integer} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_mysql_init_sql ()
{
	local -r value="${1}"

	if ! [[ -z ${value} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_mysql_root_password ()
{
	local -r value="${1}"

	if ! [[ -z ${value} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_mysql_root_password_hashed ()
{
	local -r boolean_value='^(true|false)$'
	local -r value="${1}"

	if [[ ${value} =~ ${boolean_value} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_mysql_subnet ()
{
	local -r subnet_value='^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})?$'
	local -r value="${1}"

	if [[ ${value} =~ ${subnet_value} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_mysql_user ()
{
	local -r user_value='^.{1,32}$'
	local -r value="${1}"

	if [[ ${value} =~ ${user_value} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_mysql_user_database ()
{
	local -r database_value='^[^\./\\]{0,63}[^\./\\ ]$'
	local -r value="${1}"

	if [[ ${value} =~ ${database_value} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_mysql_user_password ()
{
	local -r value="${1}"

	if ! [[ -z ${value} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_mysql_user_password_hashed ()
{
	local -r boolean_value='^(true|false)$'
	local -r value="${1}"

	if [[ ${value} =~ ${boolean_value} ]]
	then
		return 0
	fi

	return 1
}

function __map_mysql_service_user_to_datadir ()
{
	local -r datadir="${1:-"$(
		__get_option \
			mysqld \
			datadir \
			"/var/lib/mysql"
	)"}"
	local -r service_user="${3:-"$(
		__get_option \
			mysqld \
			user \
			"mysql"
	)"}"
	local -r socket="${2:-"$(
		__get_option \
			mysqld \
			socket \
			"/var/run/mysqld/mysql.sock"
	)"}"
	local -r socket_directory="${socket%/*}"

	local datadir_gid
	local datadir_uid
	local service_user_gid
	local service_user_uid

	if [[ ! -d ${datadir} ]]
	then
		return 0
	fi

	datadir_gid="$(
		stat \
			-c \
			"%g" \
			"${datadir}"
	)"
	datadir_uid="$(
		stat \
			-c \
			"%u" \
			"${datadir}"
	)"
	service_user_gid="$(
		id \
			-g \
			"${service_user}"
	)"
	service_user_uid="$(
		id \
			-u \
			"${service_user}"
	)"

	if [[ ${datadir_gid} -gt 0 ]] \
		&& [[ ${datadir_gid} != ${service_user_gid} ]]
	then
		groupmod \
			-g \
			"${datadir_gid}" \
			"${service_user}"
	fi

	if [[ ${datadir_uid} -gt 0 ]] \
		&& [[ ${datadir_uid} != ${service_user_uid} ]]
	then
		usermod \
			-u \
			"${datadir_uid}" \
			"${service_user}"
		chown \
			-R \
			"${service_user}" \
			"${socket_directory}"
	fi
}

function main ()
{
	local -r lock_file="/var/lock/subsys/mysqld-bootstrap"
	local -r mysqld="/usr/sbin/mysqld"
	local -r redacted_value="********"
	local -r server_key="${datadir}"/server-key.pem
	local -r timer_start="$(
		date +%s.%N
	)"

	local counter
	local datadir
	local mysql_init
	local mysql_init_limit
	local mysql_init_sql
	local mysql_root_password
	local mysql_root_password_hashed
	local mysql_user
	local mysql_user_database
	local mysql_user_host
	local mysql_user_password
	local mysql_user_password_hashed
	local -a pids
	local server_key_path
	local user_details
	local verbose="false"

	# Create lock
	touch \
		"${lock_file}"

	# Parse options
	while [[ "${#}" -gt 0 ]]
	do
		case "${1}" in
			-v|--verbose)
				verbose="true"
				shift 1
				;;
		esac
	done

	datadir="$(
		__get_option \
			mysqld \
			datadir \
			"/var/lib/mysql"
	)"

	# Initialisation is a one-shot process.
	if ! __is_mysql_datadir_populated "${datadir}"
	then
		# Certificate generation
		if [[ -x /usr/bin/mysql_ssl_rsa_setup ]] \
			&& [[ ! -e ${server_key} ]]
		then
			if [[ ${verbose} == true ]]
			then
				printf -- \
					"Generating MySQL certificates.\n"
			fi
			server_key_path="$(
				mktemp -d
			)"

			if [[ ${?} -ne 0 ]]
			then
				>&2 printf -- \
					'%s %s %s\n' \
					"ERROR: Failed to create directory" \
					"${server_key_path}" \
					"- aborting."
				exit 1
			fi

			trap \
				"rm -rf \"${server_key_path}\";" \
				INT TERM EXIT

			/usr/bin/mysql_ssl_rsa_setup \
				--datadir="${server_key_path}" \
				--uid=mysql \
			&> /dev/null \
			&
			pids[2]="${!}"
		fi

		mysql_init_limit="$(
			__get_mysql_init_limit
		)"
		mysql_init_sql="$(
			__get_mysql_init_sql
		)"
		mysql_root_password="$(
			__get_mysql_root_password
		)"
		mysql_root_password_hashed="$(
			__get_mysql_root_password_hashed
		)"
		mysql_user="$(
			__get_mysql_user
		)"
		mysql_user_database="$(
			__get_mysql_user_database
		)"
		# User dependent
		if [[ -n ${mysql_user} ]]
		then
			mysql_user_host="$(
				__get_mysql_user_host
			)"
			mysql_user_password="$(
				__get_mysql_user_password
			)"
			mysql_user_password_hashed="$(
				__get_mysql_user_password_hashed
			)"
		fi

		if [[ ${verbose} == true ]]
		then
			printf -- \
				"Initialising MySQL data directory.\n"
		fi

		if command -v mysql_install_db &> /dev/null
		then
			mysql_install_db \
				--force \
				--skip-name-resolve \
				--skip-networking \
				--tmpdir="${datadir}" \
				&
		else
			${mysqld} \
				--datadir="${datadir}" \
				--initialize-insecure \
				--pid-file=/var/run/mysqld/mysqld.pid \
				--skip-name-resolve \
				--skip-networking \
				--tmpdir="${datadir}" \
				--user=mysql \
				&
		fi
		pids[0]="${!}"

		# Adjust the UID/GID values of the service user to match a directory
		# that could be a mounted volume
		__map_mysql_service_user_to_datadir \
			"${datadir}" \
			&
		pids[1]="${!}"

		# Initialisation template output
		if [[ ${verbose} == true ]]
		then
			__get_mysql_init_template \
				--user="${mysql_user}" \
				--database="${mysql_user_database}" \
				--host="${mysql_user_host}" \
				--password-hashed="${mysql_user_password_hashed}" \
				--init-sql="${mysql_init_sql}"
		fi

		# Replace compact template placeholders with values
		mysql_init="$(
			__get_mysql_init_template \
				--user="${mysql_user}" \
				--database="${mysql_user_database}" \
				--host="${mysql_user_host}" \
				--password-hashed="${mysql_user_password_hashed}" \
				--init-sql="${mysql_init_sql}" \
				--compact
		)"
		mysql_init="${mysql_init//'{{MYSQL_USER}}'/${mysql_user}}"
		mysql_init="${mysql_init//'{{MYSQL_USER_DATABASE}}'/${mysql_user_database}}"
		mysql_init="${mysql_init//'{{MYSQL_USER_HOST}}'/${mysql_user_host}}"
		mysql_init="${mysql_init//'{{MYSQL_USER_PASSWORD}}'/${mysql_user_password}}"
		mysql_init="${mysql_init//'{{MYSQL_ROOT_PASSWORD}}'/${mysql_root_password}}"

		printf -- \
			'%s\n' \
			"${mysql_init}" \
			> /tmp/mysql-init

		trap \
			"rm -rf \"${server_key_path}\"; \
				rm -f /tmp/mysql-init;" \
			INT TERM EXIT

		# Wait to complete system table installation
		if [[ ${pids[0]} -gt 0 ]]
		then
			wait ${pids[0]}
		fi

		if [[ ${verbose} == true ]]
		then
			printf -- \
				"Initialising MySQL.\n"
		fi

		if command -v mysqld_safe &> /dev/null
		then
			mysqld_safe \
				--skip-networking \
				--init-file=/tmp/mysql-init \
				&
		else
			${mysqld} \
				--pid-file=/var/run/mysqld/mysqld.pid \
				--skip-networking \
				--init-file=/tmp/mysql-init \
				&
		fi

		__configure_mysql_client_root_password \
			"${mysql_root_password}"

		# Wait for initialisation to complete (poll for access) or timeout
		counter="$((
			2 * mysql_init_limit
		))"
		until (( counter == 0 ))
		do
			sleep 0.5

			if __have_mysql_access
			then
				# Set the password if it was supplied pre-hashed.
				if [[ ${mysql_root_password_hashed} == true ]]
				then
					mysql \
						-e "UPDATE mysql.user \
							SET authentication_string = '${mysql_root_password}' \
							WHERE User = 'root' \
							AND Host = 'localhost'; \
							FLUSH PRIVILEGES;"

					rm -f \
						/root/.{my,mylogin}.cnf
				fi

				break
			fi

			(( counter -= 1 ))
		done

		if [[ ${counter} -eq 0 ]]
		then
			>&2 printf \
				-- "MySQL initilisation failed after %s seconds.\n" \
				"${mysql_init_limit}"

			killall \
				-15 \
				mysqld

			exit 1
		else
			if [[ ${verbose} == true ]]
			then
				printf -- \
					"Stopping MySQL.\n"
			fi

			# Prefer mysqladmin shutdown method if password is known
			if [[ ${mysql_root_password_hashed} == true ]]
			then
				killall \
					-w \
					-15 \
					mysqld
			else
				mysqladmin \
					--user=root \
					shutdown
			fi

			rm -f \
				/tmp/mysql-init

			trap \
				"rm -rf \"${server_key_path}\";" \
				INT TERM EXIT
		fi

		# Local root user details
		if [[ ${verbose} == true ]]
		then
			printf \
				-v user_details \
				-- "user : %s@%s, password : %s" \
				root \
				localhost \
				"${redacted_value}"
		fi

		if [[ -n ${mysql_user} ]]
		then
			# Redact operator supplied password
			if [[ -n ${MYSQL_USER_PASSWORD} ]]
			then
				mysql_user_password="${redacted_value}"
			fi

			if [[ ${verbose} == true ]]
			then
				printf \
					-v user_details \
					-- "%s\nuser : %s@%s, password : %s" \
					"${user_details}" \
					"${mysql_user}" \
					"${mysql_user_host}" \
					"${mysql_user_password}"
			else
				printf \
					-v user_details \
					-- "user : %s@%s, password : %s" \
					"${mysql_user}" \
					"${mysql_user_host}" \
					"${mysql_user_password}"
			fi
		fi

		# Wait for the service user modifications to complete
		if [[ ${pids[1]} -gt 0 ]]
		then
			wait ${pids[1]}
		fi

		# Wait to complete certificate generation
		if [[ ${pids[2]} -gt 0 ]]
		then
			wait ${pids[2]}
		fi

		# Finalise certificate setup
		if [[ -f ${server_key_path}/server-key.pem ]]
		then
			mv \
				"${server_key_path}"/server-key.pem \
				"${server_key}"
			rm -rf \
				"${server_key_path}"

			trap - \
				INT TERM EXIT
		fi

		if [[ ${verbose} == true ]]
		then
			timer_total="$(
				awk \
					-v timer_end="$(
						date +%s.%N
					)" \
					-v timer_start="${timer_start}" \
					'BEGIN { print \
						timer_end - timer_start;
					}'
			)"

			cat \
				<<-EOT

				================================================================================
				MySQL Details
				--------------------------------------------------------------------------------
				database : ${mysql_user_database:-N/A}
				${user_details}
				--------------------------------------------------------------------------------
				${timer_total}

			EOT
		elif [[ ${mysql_user_password} != "${redacted_value}" ]]
		then
			cat \
				<<-EOT

				================================================================================
				MySQL Details
				--------------------------------------------------------------------------------
				${user_details}
				--------------------------------------------------------------------------------

			EOT
		fi
	fi

	# Release lock
	rm -f \
		"${lock_file}"
}

main "${@}"
