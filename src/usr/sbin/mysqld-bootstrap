#!/usr/bin/env bash

# Create lock
touch /var/lock/subsys/mysqld-bootstrap

timer_start="$(
	date +%s.%N
)"

source /etc/mysqld-bootstrap.conf

# Set MySQL client root user password
# - Prefer to store encrypted via mysql_config_editor.
# - Fallback to store as plaintext in secured file.
function __configure_mysql_client_root_password ()
{
	local -r password="${1:-}"

	local config
	local -a pids

	if [[ -z ${password} ]]
	then
		return 1
	fi

	if command -v mysql_config_editor &> /dev/null \
		&& command -v sshpass &> /dev/null
	then
		fifo_path="$(
			mktemp -d
		)"

		if [[ ${?} -ne 0 ]]
		then
			>&2 printf -- \
				'%s %s %s\n' \
				"ERROR: Failed to create directory" \
				"${fifo_path}"
				"- aborting."
			exit 1
		fi

		trap \
			"rm -rf \"${fifo_path}\";" \
			INT TERM EXIT

		mkfifo \
			-m 0600 \
			"${fifo_path}/mypasswd"

		exec \
			{mypasswd_fd}<>"${fifo_path}/mypasswd"

		trap \
			"exec {mypasswd_fd}>&- ;" \
			INT TERM EXIT

		rm -rf \
			"${fifo_path}"

		# Send into background waiting to read the password
		sshpass \
			-d ${mypasswd_fd} \
			mysql_config_editor \
				set \
				--skip-warn \
				--password \
				&
		pids[1]="${!}"

		trap \
			"exec {mypasswd_fd}>&- ; \
				[[ ${pids[1]} -gt 0 ]] && kill -9 ${pids[1]};" \
			INT TERM EXIT

		printf -- \
			'%s\n' \
			"${password}" \
			>&${mypasswd_fd} \
			&
		pids[2]="${!}"

		trap \
			"exec {mypasswd_fd}>&- ; \
				[[ ${pids[1]} -gt 0 ]] && kill -9 ${pids[1]}; \
				[[ ${pids[2]} -gt 0 ]] && kill -9 ${pids[2]};" \
			INT TERM EXIT

		if [[ ${pids[1]} -gt 0 ]]
		then
			wait ${pids[1]}
		fi

		if [[ ${?} -ne 0 ]]
		then
			>&2 printf -- \
				"ERROR: Unable to set MySQL root password - aborting.\n"
			exit 1
		fi

		exec \
			{mypasswd_fd}>&-
	else
		tee /root/.my.cnf &> /dev/null \
			<<-EOT
			[client]
			password={{MYSQL_ROOT_PASSWORD}}
		EOT

		chown root:root \
			/root/.my.cnf
		chmod 0600 \
			/root/.my.cnf

		config="$(< /root/.my.cnf)"

		printf -- \
			'%s\n' \
			"${config//'{{MYSQL_ROOT_PASSWORD}}'/${password}}" \
			> /root/.my.cnf
	fi

	trap - \
		INT TERM EXIT
}

function __get_mysql_init_template ()
{
	local compact="false"
	local database
	local host
	local init_sql="-- Custom Initialisation SQL"
	local password_hashed="false"
	local -a pids
	local template_database="-- Create database"
	local template_identified_by="IDENTIFIED BY"
	local template_privileges="-- Grant privileges"
	local template_user="-- Create user"
	local user

	# Parse options
	while [[ "${#}" -gt 0 ]]
	do
		case "${1}" in
			--compact|--compact=true)
				compact="true"
				shift 1
				;;
			--compact=*)
				compact="false"
				shift 1
				;;
			--database=*)
				database="${1#*=}"
				shift 1
				;;
			--host=*)
				host="${1#*=}"
				shift 1
				;;
			--init-sql=*)
				init_sql="${1#*=}"
				shift 1
				;;
			--password-hashed|--password-hashed=true)
				password_hashed="true"
				shift 1
				;;
			--password-hashed=*)
				password_hashed="false"
				shift 1
				;;
			--user=*)
				user="${1#*=}"
				shift 1
				;;
			*)
				>&2 printf -- \
					'ERROR: Unknown option %s\n' \
					"${1}"
				return 1
				;;
		esac
	done

	fifo_path="$(
		mktemp -d
	)"

	if [[ ${?} -ne 0 ]]
	then
		>&2 printf -- \
			'%s %s %s\n' \
			"ERROR: Failed to create directory" \
			"${fifo_path}"
			"- aborting."
		exit 1
	fi

	trap \
		"rm -rf \"${fifo_path}\";" \
		INT TERM EXIT

	mkfifo \
		-m 0600 \
		"${fifo_path}"/mysql-init-template

	if [[ -n ${database} ]]
	then
		printf \
			-v template_database \
			-- "%s\nCREATE DATABASE IF NOT EXISTS \`%s\`;" \
			"${template_database}" \
			"{{MYSQL_USER_DATABASE}}"
	fi

	if [[ -n ${user} ]] \
		&& [[ -n ${host} ]]
	then
		if [[ ${password_hashed} == true ]]
		then
			template_identified_by+=" PASSWORD"
		fi

		printf \
			-v template_user \
			-- "%s\nCREATE USER '%s'@'%s' \n%s '%s';" \
			"${template_user}" \
			"{{MYSQL_USER}}" \
			"{{MYSQL_USER_HOST}}" \
			"${template_identified_by}" \
			"{{MYSQL_USER_PASSWORD}}"
	fi

	if [[ -n ${user} ]] \
		&& [[ -n ${database} ]] \
		&& [[ -n ${host} ]]
	then
		printf \
			-v template_privileges \
			-- "%s\nGRANT %s \nON \`%s\`.* \nTO '%s'@'%s';" \
			"${template_privileges}" \
			"ALL PRIVILEGES" \
			"{{MYSQL_USER_DATABASE}}" \
			"{{MYSQL_USER}}" \
			"{{MYSQL_USER_HOST}}"
	fi

	# Listen for the template and output as required
	if [[ ${compact} == false ]]
	then
		cat <<-EOF &
			$(<"${fifo_path}"/mysql-init-template)
		EOF
	else
		cat -s \
			<<-EOF | \
				sed \
					-e '/^[ \t]*--.*$/d' \
					-e 's/;[ \t]*--.*$/;/g' \
					-e '/^$/d' \
					| \
				awk \
					'{ ORS=( /;$/ ? RS:FS ) } 1' \
				&
			$(<"${fifo_path}"/mysql-init-template)
		EOF
	fi
	pids[1]="${!}"

	# Generate the initialisation SQL template
	cat \
		<<-EOT > "${fifo_path}"/mysql-init-template &

		-- =============================================================================
		-- Initialisation SQL
		-- -----------------------------------------------------------------------------
		-- Secure MySQL
		DROP DATABASE IF EXISTS test;
		DELETE FROM mysql.user WHERE User='' OR User='root' AND Host != 'localhost';
		DELETE FROM mysql.db WHERE Db='test' OR Db='test\\_%';
		${template_database}
		${template_user}
		-- =============================================================================
		-- Custom Initialisation SQL start
		-- 
		${init_sql}
		-- 
		-- Custom Initialisation SQL end
		-- -----------------------------------------------------------------------------
		${template_privileges}
		GRANT ALL PRIVILEGES 
		ON *.* 
		TO 'root'@'localhost' 
		IDENTIFIED BY '{{MYSQL_ROOT_PASSWORD}}' 
		WITH GRANT OPTION;
		FLUSH PRIVILEGES;
	EOT
	pids[2]="${!}"

	trap \
		"rm -rf \"${fifo_path}\"; \
			[[ ${pids[1]} -gt 0 ]] && kill -9 ${pids[1]}; \
			[[ ${pids[2]} -gt 0 ]] && kill -9 ${pids[2]};" \
		INT TERM EXIT

	if [[ ${pids[1]} -gt 0 ]]
	then
		wait ${pids[1]}
	fi

	if [[ ${?} -ne 0 ]]
	then
		>&2 printf -- \
			"ERROR: Unable to gererate MySQL init template - aborting.\n"
		exit 1
	fi

	rm -rf \
		"${fifo_path}"

	trap - \
		INT TERM EXIT
}

function __get_mysql_user_host ()
{
	local -r client_subnet="${1:-127.0.0.1}"

	local value

	case "${client_subnet}" in
		0.0.0.0|0.0.0.0/0.0.0.0)
			# Connect from any network
			value="%"
			;;
		127.0.0.1)
			# Internal connection
			value="localhost"
			;;
		*)
			# User defined host / subnet
			value="${client_subnet}"
			;;
	esac

	printf -- '%s' "${value}"
}

function __get_option ()
{
	local -r value="$(
		/usr/bin/my_print_defaults "${1}" \
		| sed -n "s/^--${2}=//p" \
		| tail -n 1
	)"

	printf -- '%s' "${value:-"${3}"}"
}

function __get_password ()
{
	local -r length="${1:-16}"
	local -r password="$(
		head -n 4096 /dev/urandom \
		| tr -cd '[:alnum:]' \
		| cut -c1-"${length}"
	)"

	printf -- '%s' "${password}"
}

function __have_mysql_access ()
{
	local -r database="${3:-mysql}"
	local -r password="${2:-}"
	local -r user="${1:-root}"

	if [[ ${user} == root ]]
	then
		if mysql \
			--protocol=socket \
			--user="${user}" \
			-e "use ${database}" \
			2> /dev/null;
		then
			return 0
		fi
	else
		if mysql \
			--protocol=socket \
			--user="${user}" \
			--password="${password}" \
			-e "use ${database}" \
			2> /dev/null;
		then
			return 0
		fi
	fi

	return 1
}

function __is_mysql_datadir_populated ()
{
	local -r directory="${1:-"$(
		__get_option \
			mysqld \
			datadir \
			"/var/lib/mysql"
	)"}"

	# Test for the InnoDB shared tablespace
	if [[ -f ${directory}/ibdata1 ]]
	then
		return 0
	fi

	return 1
}

function __map_mysql_service_user_to_datadir ()
{
	local -r datadir="${1:-"$(
		__get_option \
			mysqld \
			datadir \
			"/var/lib/mysql"
	)"}"
	local -r service_user="${3:-"$(
		__get_option \
			mysqld \
			user \
			"mysql"
	)"}"
	local -r socket="${2:-"$(
		__get_option \
			mysqld \
			socket \
			"/var/run/mysqld/mysql.sock"
	)"}"
	local -r socket_directory="${socket%/*}"

	local datadir_gid
	local datadir_uid
	local service_user_gid
	local service_user_uid

	if [[ ! -d ${datadir} ]]
	then
		return 0
	fi

	datadir_gid="$(
		stat \
			-c \
			"%g" \
			"${datadir}"
	)"
	datadir_uid="$(
		stat \
			-c \
			"%u" \
			"${datadir}"
	)"
	service_user_gid="$(
		id \
			-g \
			"${service_user}"
	)"
	service_user_uid="$(
		id \
			-u \
			"${service_user}"
	)"

	if [[ ${datadir_gid} -gt 0 ]] \
		&& [[ ${datadir_gid} != ${service_user_gid} ]]
	then
		groupmod \
			-g \
			"${datadir_gid}" \
			"${service_user}"
	fi

	if [[ ${datadir_uid} -gt 0 ]] \
		&& [[ ${datadir_uid} != ${service_user_uid} ]]
	then
		usermod \
			-u \
			"${datadir_uid}" \
			"${service_user}"
		chown \
			-R \
			"${service_user}" \
			"${socket_directory}"
	fi
}

OPTS_MYSQL_DATADIR="$(
	__get_option \
		mysqld \
		datadir \
		"/var/lib/mysql"
)"

# MySQL initialisation is a one-shot process.
if ! __is_mysql_datadir_populated "${OPTS_MYSQL_DATADIR}"
then
	readonly mysqld=/usr/sbin/mysqld
	readonly redacted_value="********"
	readonly server_key="${OPTS_MYSQL_DATADIR}"/server-key.pem
	server_key_path=""

	if [[ -x /usr/bin/mysql_ssl_rsa_setup ]] \
		&& [[ ! -e ${server_key} ]]
	then
		printf -- \
			"Generating MySQL certificates.\n"
		server_key_path="$(
			mktemp -d
		)"

		if [[ ${?} -ne 0 ]]
		then
			>&2 printf -- \
				'%s %s %s\n' \
				"ERROR: Failed to create directory" \
				"${server_key_path}"
				"- aborting."
			exit 1
		fi

		trap \
			"rm -rf \"${server_key_path}\";" \
			INT TERM EXIT

		/usr/bin/mysql_ssl_rsa_setup \
			--datadir="${server_key_path}" \
			--uid=mysql \
		&> /dev/null \
		&
		PIDS[2]="${!}"
	fi

	# Get passwords from file if applicable
	if [[ -s ${MYSQL_ROOT_PASSWORD} ]]
	then
		MYSQL_ROOT_PASSWORD="$(< "${MYSQL_ROOT_PASSWORD}")"
	fi

	if [[ -s ${MYSQL_USER_PASSWORD} ]]
	then
		MYSQL_USER_PASSWORD="$(< "${MYSQL_USER_PASSWORD}")"
	fi

	OPTS_MYSQL_INIT_LIMIT="${MYSQL_INIT_LIMIT:-60}"
	OPTS_MYSQL_INIT_SQL="${CUSTOM_MYSQL_INIT_SQL:-}"
	OPTS_MYSQL_ROOT_PASSWORD="${MYSQL_ROOT_PASSWORD:-"$(
		__get_password
	)"}"
	OPTS_MYSQL_ROOT_PASSWORD_HASHED="${MYSQL_ROOT_PASSWORD_HASHED:-false}"
	OPTS_MYSQL_USER="${MYSQL_USER:-}"
	OPTS_MYSQL_USER_DATABASE="${MYSQL_USER_DATABASE:-}"
	OPTS_MYSQL_USER_HOST="$(
		__get_mysql_user_host \
		"${MYSQL_SUBNET:-127.0.0.1}"
	)"
	OPTS_MYSQL_USER_PASSWORD="${MYSQL_USER_PASSWORD:-"$(
		__get_password
	)"}"
	OPTS_MYSQL_USER_PASSWORD_HASHED="${MYSQL_USER_PASSWORD_HASHED:-false}"

	printf -- \
		"Initalising MySQL data directory.\n"
	${mysqld} \
		--datadir="${OPTS_MYSQL_DATADIR}" \
		--initialize-insecure \
		--pid-file=/var/run/mysqld/mysqld.pid \
		--skip-name-resolve \
		--skip-networking \
		--tmpdir="${OPTS_MYSQL_DATADIR}" \
		--user=mysql \
		&
	PIDS[0]="${!}"

	# Adjust the UID/GID values of the service user to match a directory that
	# could be a mounted volume
	__map_mysql_service_user_to_datadir \
		"${OPTS_MYSQL_DATADIR}" \
		&
	PIDS[1]="${!}"

	# MySQL Initialisation Template logs output
	__get_mysql_init_template \
		--user="${OPTS_MYSQL_USER}" \
		--database="${OPTS_MYSQL_USER_DATABASE}" \
		--host="${OPTS_MYSQL_USER_HOST}" \
		--password-hashed="${OPTS_MYSQL_USER_PASSWORD_HASHED}" \
		--init-sql="${OPTS_MYSQL_INIT_SQL}"

	# Replace compact template placeholders with values
	mysql_init_template="$(
		__get_mysql_init_template \
			--user="${OPTS_MYSQL_USER}" \
			--database="${OPTS_MYSQL_USER_DATABASE}" \
			--host="${OPTS_MYSQL_USER_HOST}" \
			--password-hashed="${OPTS_MYSQL_USER_PASSWORD_HASHED}" \
			--init-sql="${OPTS_MYSQL_INIT_SQL}" \
			--compact
	)"
	mysql_init_template="${mysql_init_template//'{{MYSQL_USER}}'/${OPTS_MYSQL_USER}}"
	mysql_init_template="${mysql_init_template//'{{MYSQL_USER_DATABASE}}'/${OPTS_MYSQL_USER_DATABASE}}"
	mysql_init_template="${mysql_init_template//'{{MYSQL_USER_HOST}}'/${OPTS_MYSQL_USER_HOST}}"
	mysql_init_template="${mysql_init_template//'{{MYSQL_USER_PASSWORD}}'/${OPTS_MYSQL_USER_PASSWORD}}"
	mysql_init_template="${mysql_init_template//'{{MYSQL_ROOT_PASSWORD}}'/${OPTS_MYSQL_ROOT_PASSWORD}}"

	printf -- \
		'%s\n' \
		"${mysql_init_template}" \
		> /tmp/mysql-init

	trap \
		"rm -rf \"${server_key_path}\"; \
			rm -f /tmp/mysql-init;" \
		INT TERM EXIT

	# Wait for the MySQL system table installation to complete
	if [[ ${PIDS[0]} -gt 0 ]]
	then
		wait ${PIDS[0]}
	fi

	printf -- \
		"Initialising MySQL.\n"
	${mysqld} \
		--pid-file=/var/run/mysqld/mysqld.pid \
		--skip-networking \
		--init-file=/tmp/mysql-init \
		&

	__configure_mysql_client_root_password \
		"${OPTS_MYSQL_ROOT_PASSWORD}"

	# Wait for the MySQL database to be initialised by testing 
	COUNTER=$((
		2 * OPTS_MYSQL_INIT_LIMIT
	))
	until (( COUNTER == 0 ))
	do
		sleep 0.5

		if __have_mysql_access
		then
			# Set the password if it was supplied pre-hashed.
			if [[ ${OPTS_MYSQL_ROOT_PASSWORD_HASHED} == true ]]
			then
				mysql \
					-e "UPDATE mysql.user SET authentication_string = '${OPTS_MYSQL_ROOT_PASSWORD}' WHERE User = 'root' AND Host = 'localhost'; FLUSH PRIVILEGES;"

				rm -f \
					/root/.{my,mylogin}.cnf
			fi

			break
		fi

		(( COUNTER -= 1 ))
	done

	if [[ ${COUNTER} -eq 0 ]]
	then
		>&2 printf \
			-- "MySQL initilisation failed after %s seconds.\n" \
			"${OPTS_MYSQL_INIT_LIMIT}"

		killall \
			-15 \
			mysqld

		exit 1
	else
		printf --\
			"Stopping MySQL.\n"

		# Prefer mysqladmin shutdown method if password is known
		if [[ ${OPTS_MYSQL_ROOT_PASSWORD_HASHED} == true ]]
		then
			killall \
				-w \
				-15 \
				mysqld
		else
			mysqladmin \
				--user=root \
				shutdown
		fi

		rm -f \
			/tmp/mysql-init

		trap \
			"rm -rf \"${server_key_path}\";" \
			INT TERM EXIT
	fi

	# Local root user details
	printf \
		-v DETAILS_MYSQL_USER_CREDENTIALS \
		-- "user : %s@%s, password : %s" \
		root \
		localhost \
		"${redacted_value}"

	if [[ -n ${OPTS_MYSQL_USER} ]] \
		&& [[ -n ${OPTS_MYSQL_USER_PASSWORD} ]]
	then
		# Redact operator supplied password
		if [[ -n ${MYSQL_USER_PASSWORD} ]]
		then
			OPTS_MYSQL_USER_PASSWORD="${redacted_value}"
		fi

		printf \
			-v DETAILS_MYSQL_USER_CREDENTIALS \
			-- "%s\nuser : %s@%s, password : %s" \
			"${DETAILS_MYSQL_USER_CREDENTIALS}" \
			"${OPTS_MYSQL_USER}" \
			"${OPTS_MYSQL_USER_HOST}" \
			"${OPTS_MYSQL_USER_PASSWORD}"
	fi

	# Wait for the service user modifications to complete
	if [[ ${PIDS[1]} -gt 0 ]]
	then
		wait ${PIDS[1]}
	fi

	# Wait for the MySQL certificate setup to complete
	if [[ ${PIDS[2]} -gt 0 ]]
	then
		wait ${PIDS[2]}
	fi

	# Finalise certificate setup
	if [[ -f ${server_key_path}/server-key.pem ]]
	then
		mv \
			"${server_key_path}"/server-key.pem \
			"${server_key}"
		rm -rf \
			"${server_key_path}"

		trap - \
			INT TERM EXIT
	fi

	timer_total="$(
		awk \
			-v timer_end="$(
				date +%s.%N
			)" \
			-v timer_start="${timer_start}" \
			'BEGIN { print \
				timer_end - timer_start;
			}'
	)"

	# Send to log file until user password can be stored in configuration file.
	tee /var/log/mysqld.log \
		<<-EOT

		================================================================================
		MySQL Details
		--------------------------------------------------------------------------------
		database : ${OPTS_MYSQL_USER_DATABASE:-N/A}
		${DETAILS_MYSQL_USER_CREDENTIALS}
		--------------------------------------------------------------------------------
		${timer_total}

	EOT
fi

# Release lock
rm -f \
	/var/lock/subsys/mysqld-bootstrap
